//Algorithm 3. Transaction limit

//Simplified version: assume # of input =1 ,# of output =2

//*******************************************************************************

//PrivateInput: CoinsIn,CoinsOut

//PublicInput : sig

//Constants : limit

//output : True if transaction is valid

//********************************************************************************
//Notes:
//
// 1 No bitwise operation(e.g. and, or, not, ...)
//   No True,False
//   No >=, <=, >, only ==, <  !!!
//	b/c we do operation in some fininite field with high order
//	There are only +,-,*,/, in field
//
//
// 2 no if-else --> if-then-else-fi instead
//
// 3 def main( public-input-1, public-input-2, ...)
//
//	intermidiate are all private-input
//
// 4 if-statement can't contain function 

// TODO
def VerifySig(CA, CoinOutValue, CoinOutAddr, CoinOutRemain , sig ) :    
    return 0


def NotEqual( x, y):    
    return  if x == y then 0 else 1 fi 


def main( CA, limit, sig1, sig2 ):
    
    // 1 if tx signed by authorized party, skip policy 
    IsTxSigned = sig1 * sig2
    IsSigValid = if 0 < IsTxSigned then ( VerifySig(CA, CoinOut1Value, CoinOut1Addr, CoinOut1Remain , sig1 ) * VerifySig(CA, CoinOut2Value, CoinOut2Addr, CoinOut2Remain , sig2 )) else 2 fi
    // `*` play the role of `and`
    // if signed , sig is ok      --> 1
    // 	           sig is invalid --> 0
    // not signed, skip policy    --> 2




    // 2 if we are paying to an input address, it is change  back
    //	to the user and not counted against the limit
    IsCoinOut1Change =  NotEqual( CoinOut1Addr, CoinInAddr )  
    IsCoinOut2Change =  NotEqual( CoinOut2Addr, CoinInAddr )  
    sent = 0
    sent = if IsCoinOut1Change == 0 then sent + CoinOut1Value else sent fi
    sent = if IsCoinOut2Change == 0 then sent + CoinOut2Value else sent fi
 	
	
    IsTxValid = if limit < sent then 0 else 1 fi
    return IsTxValid
